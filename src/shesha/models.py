"""Core data models for Shesha."""

import json
from collections.abc import Callable
from dataclasses import dataclass, field
from typing import TYPE_CHECKING, Any, Literal

if TYPE_CHECKING:
    from shesha.project import Project


@dataclass
class ProjectInfo:
    """Metadata about a project's source."""

    project_id: str
    source_url: str | None
    is_local: bool
    source_exists: bool
    analysis_status: Literal["current", "stale", "missing"] | None = None


@dataclass
class ParsedDocument:
    """A parsed document ready for storage and querying."""

    name: str
    content: str
    format: str
    metadata: dict[str, str | int | float | bool]
    char_count: int
    parse_warnings: list[str] = field(default_factory=list)


@dataclass
class RepoProjectResult:
    """Result from create_project_from_repo()."""

    project: "Project"
    status: Literal["created", "unchanged", "updates_available"]
    files_ingested: int
    files_skipped: int = 0
    warnings: list[str] = field(default_factory=list)
    _apply_updates_fn: Callable[[], "RepoProjectResult"] | None = field(default=None, repr=False)

    def apply_updates(self) -> "RepoProjectResult":
        """Pull changes and re-ingest. Only valid when status is 'updates_available'."""
        if self.status != "updates_available":
            raise ValueError("apply_updates() is only valid when status is 'updates_available'")
        if self._apply_updates_fn is None:
            raise ValueError("No apply_updates function provided")
        return self._apply_updates_fn()


@dataclass
class QueryContext:
    """Metadata about a query for trace logging."""

    trace_id: str
    question: str
    document_ids: list[str]
    model: str
    system_prompt: str
    subcall_prompt: str


def coerce_to_str(value: Any) -> str:
    """Coerce a value to a string. Dicts/lists are JSON-encoded."""
    if isinstance(value, str):
        return value
    return json.dumps(value)


def coerce_to_str_list(items: list[Any]) -> list[str]:
    """Coerce list items to strings. Dict items use their 'name' key or JSON."""
    result = []
    for item in items:
        if isinstance(item, str):
            result.append(item)
        elif isinstance(item, dict) and "name" in item:
            result.append(coerce_to_str(item["name"]))
        else:
            result.append(json.dumps(item))
    return result


def _validate_str(value: Any, field_name: str) -> None:
    """Raise TypeError if value is not a str."""
    if not isinstance(value, str):
        raise TypeError(f"{field_name} must be str, got {type(value).__name__}")


def _validate_str_list(items: list[Any], field_name: str) -> None:
    """Raise TypeError if any item in the list is not a str."""
    for item in items:
        if not isinstance(item, str):
            raise TypeError(f"all items in {field_name} must be str, got {type(item).__name__}")


@dataclass
class AnalysisComponent:
    """A component within a codebase analysis."""

    name: str
    path: str
    description: str
    apis: list[dict[str, Any]]
    models: list[str]
    entry_points: list[str]
    internal_dependencies: list[str]
    auth: str | None = None
    data_persistence: str | None = None

    def __post_init__(self) -> None:
        _validate_str(self.name, "name")
        _validate_str(self.path, "path")
        _validate_str(self.description, "description")
        _validate_str_list(self.models, "models")
        _validate_str_list(self.entry_points, "entry_points")
        _validate_str_list(self.internal_dependencies, "internal_dependencies")


@dataclass
class AnalysisExternalDep:
    """An external dependency in a codebase analysis."""

    name: str
    type: str  # external_api, database, message_queue, ai_service, auth_service, storage
    description: str
    used_by: list[str]
    optional: bool = False

    def __post_init__(self) -> None:
        _validate_str(self.name, "name")
        _validate_str(self.type, "type")
        _validate_str(self.description, "description")
        _validate_str_list(self.used_by, "used_by")


@dataclass
class RepoAnalysis:
    """Pre-computed codebase analysis for HLD builder optimization."""

    version: str
    generated_at: str
    head_sha: str
    overview: str
    components: list[AnalysisComponent]
    external_dependencies: list[AnalysisExternalDep]
    caveats: str = "This analysis was generated by AI and may be incomplete or incorrect."

    def __post_init__(self) -> None:
        _validate_str(self.overview, "overview")
        _validate_str(self.caveats, "caveats")
